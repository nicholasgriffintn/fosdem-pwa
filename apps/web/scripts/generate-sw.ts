import { glob } from 'glob'
import { writeFileSync, readFileSync, readdirSync } from 'node:fs'

const CURRENT_YEAR = 2026;

async function generateServiceWorker(outputDir = 'dist') {
  let manifest: Record<string, any>;

  try {
    manifest = JSON.parse(
      readFileSync(`${outputDir}/server/.vite/manifest.json`, 'utf-8')
    )
  } catch (error: any) {
    throw new Error('Error reading Vite manifest: ' + error.message)
  }

  if (!manifest) {
    throw new Error('Vite manifest is empty or invalid.')
  }

  const serverAssetsDir = `${outputDir}/server/assets`;
  let fosdemFunctionId: string | undefined;

  try {
    // We need to get the function ID for the server function so we can pre cache it.
    // To do this, we read the worker-entry file and extract the hash for the fosdem function.
    // Then we can use that hash to construct the server function URL.
    const workerEntryFile = readdirSync(serverAssetsDir)
      .find(f => f.startsWith('worker-entry-') && f.endsWith('.js'));

    if (workerEntryFile) {
      const workerEntryContent = readFileSync(`${serverAssetsDir}/${workerEntryFile}`, 'utf-8');
      const match = workerEntryContent.match(/"([a-f0-9]{60,})":\s*\{\s*functionName:\s*"getAllData_createServerFn_handler"/);
      if (match) {
        fosdemFunctionId = match[1];
      }
    }
  } catch (error: any) {
    console.warn('Could not find worker-entry or extract hash, falling back to manifest:', error.message);
  }

  if (!fosdemFunctionId) {
    fosdemFunctionId = Object.keys(manifest)
      .find(key => key.startsWith('src/server/functions/fosdem.ts'))
      ? manifest[
        Object.keys(manifest).find(key => key.startsWith('src/server/functions/fosdem.ts'))!
      ]?.name
      : undefined;
  }

  if (!fosdemFunctionId) {
    throw new Error('Fosdem server function hash not found.')
  }

  // This creates a payload to fetch all data for the current year, this should match what the app uses.
  const getFosdemPayload = (year: number) => ({
    t: {
      t: 10,
      i: 0,
      p: {
        k: ["data"],
        v: [
          {
            t: 10,
            i: 1,
            p: {
              k: ["year"],
              v: [
                {
                  t: 0,
                  s: year
                }
              ],
              s: 1
            },
            o: 0
          }
        ],
        s: 1
      },
      o: 0
    },
    f: 31,
    m: []
  });

  const dataUrls = [
    `/_serverFn/${fosdemFunctionId}?payload=${encodeURIComponent(JSON.stringify(getFosdemPayload(CURRENT_YEAR)))}&createServerFn`
  ]

  const clientFiles = await glob(`${outputDir}/client/**/*`, { nodir: true })

  const filesAndDataUrls = [...dataUrls, ...clientFiles, '/offline']

  const ignoredRoutes = [
    '/robots.txt',
    '/nitro.json',
    '/_routes.json',
    '/_redirects',
    '/_headers',
    '/sw.js',
    '/_worker.js',
    '/wrangler.json',
    '/manifest.webmanifest',
    '/favicon.ico',
    "/screenshots/2.png",
    "/screenshots/1.jpg",
    "/icons/safari-pinned-tab.svg",
    "/icons/mstile-150x150.png",
    "/icons/favicon.ico",
    "/icons/favicon-32x32.png",
    "/icons/favicon-16x16.png",
    "/icons/browserconfig.xml",
    "/icons/apple-touch-icon.png",
    "/icons/apple-touch-icon-precomposed.png",
    "/icons/apple-touch-icon-76x76.png",
    "/icons/apple-touch-icon-76x76-precomposed.png",
    "/icons/apple-touch-icon-72x72.png",
    "/icons/apple-touch-icon-72x72-precomposed.png",
    "/icons/apple-touch-icon-60x60.png",
    "/icons/apple-touch-icon-60x60-precomposed.png",
    "/icons/apple-touch-icon-57x57.png",
    "/icons/apple-touch-icon-57x57-precomposed.png",
    "/icons/apple-touch-icon-180x180.png",
    "/icons/apple-touch-icon-180x180-precomposed.png",
    "/icons/apple-touch-icon-152x152.png",
    "/icons/apple-touch-icon-152x152-precomposed.png",
    "/icons/apple-touch-icon-144x144.png",
    "/icons/apple-touch-icon-144x144-precomposed.png",
    "/icons/apple-touch-icon-120x120.png",
    "/icons/apple-touch-icon-120x120-precomposed.png",
    "/icons/apple-touch-icon-114x114.png",
    "/icons/apple-touch-icon-114x114-precomposed.png",
    "/icons/android-chrome-96x96.png",
    "/icons/android-chrome-72x72.png",
    "/icons/android-chrome-512x512.png",
    "/icons/android-chrome-48x48.png",
    "/icons/android-chrome-384x384.png",
    "/icons/android-chrome-36x36.png",
    "/icons/android-chrome-256x256.png",
    "/icons/android-chrome-192x192.png",
    "/icons/android-chrome-144x144.png",
  ]

  const assetsToCache = filesAndDataUrls
    .map(file => {
      if (file.startsWith('/_serverFn') || file.startsWith('/offline')) {
        return file
      }
      const relativePath = file.replace(new RegExp(`^${outputDir}/`), '');
      return `/${relativePath.replace(/^(client|server)\//, '')}`
    })
    .filter(file => !ignoredRoutes.includes(file))

  const sw = `// NOTE: This file is automatically generated by scripts/generate-sw.ts
// Do not edit this file manually.
// If you need to make changes, edit the script and run 'pnpm build' again.

importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.0.0/workbox-sw.js');

const { registerRoute, NavigationRoute, setDefaultHandler } = workbox.routing;
const { NetworkFirst, CacheFirst, StaleWhileRevalidate, NetworkOnly } = workbox.strategies;
const { CacheableResponsePlugin } = workbox.cacheableResponse;
const { ExpirationPlugin } = workbox.expiration;
const { BroadcastUpdatePlugin } = workbox.broadcastUpdate;

self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

async function syncBookmarks() {
  try {
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'TRIGGER_BACKGROUND_SYNC'
      });
    });
  } catch (error) {
    console.error('Bookmark sync trigger failed:', error);
  }
}

const CACHE_NAME = 'fosdem-pwa-v${Date.now()}';

self.addEventListener('install', () => self.skipWaiting());

let updateInterval;
self.addEventListener('online', () => {
  if (updateInterval) clearInterval(updateInterval);
  updateInterval = setInterval(() => {
    self.registration.update();
  }, 5 * 60 * 1000); // 5 minutes
});

self.addEventListener('offline', () => {
  if (updateInterval) {
    clearInterval(updateInterval);
    updateInterval = null;
  }
});

const urlsToCache = ${JSON.stringify(assetsToCache, null, 2)};

workbox.precaching.precacheAndRoute(
  urlsToCache.map(url => ({
    url,
    revision: CACHE_NAME
  }))
);

registerRoute(
  ({ url }) => url.pathname.includes('/api/user'),
  new NetworkFirst({
    cacheName: 'user-data',
    plugins: [],
    networkTimeoutSeconds: 3
  })
);

registerRoute(
  ({ url }) => url.hostname === 'avatars.githubusercontent.com',
  new CacheFirst({
    cacheName: 'github-avatars',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
      })
    ]
  })
);

registerRoute(
  ({ url }) => url.hostname === 'images.s3rve.co.uk',
  new CacheFirst({
    cacheName: 'resized-images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
      })
    ]
  })
);

registerRoute(
  new NavigationRoute(
    new NetworkFirst({
      cacheName: 'navigations',
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200]
        }),
        new ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 24 * 60 * 60 // 24 hours
        })
      ]
    }),
    {
      allowlist: [new RegExp('^(?!/api/).*$')], // All non-API routes
    }
  )
);

registerRoute(
  ({ url }) => url.pathname.startsWith('/_serverFn'),
  new NetworkFirst({
    cacheName: 'server-functions',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      {
        handlerDidError: async ({ request }) => {
          const url = new URL(request.url);
          if (url.pathname.includes('/_serverFn/') && url.searchParams.get('payload')) {
            try {
              const payloadParam = url.searchParams.get('payload');
              if (payloadParam) {
                const payload = JSON.parse(decodeURIComponent(payloadParam));
                if (payload.t?.p?.v?.[1]?.p?.k?.includes('slug')) {
                  // Return empty state for offline mode
                  return new Response(JSON.stringify(null), {
                    status: 200,
                    headers: { 'Content-Type': 'application/json' }
                  });
                }
              }
            } catch (e) {
              // If parsing fails, continue to default error handling
            }
          }
          return null;
        }
      }
    ],
    networkTimeoutSeconds: 6
  })
);

setDefaultHandler(
  new NetworkOnly({
    plugins: [
      {
        handlerDidError: async ({ request }) => {
          const url = new URL(request.url);
          
          if (url.pathname.startsWith('/_serverFn')) {
            return new Response('', {
              status: 200,
              headers: { 'Content-Type': 'application/json' }
            });
          }
          
          // For anything else, serve the offline page
          try {
            return await caches.match('/offline');
          } catch (e) {
            return new Response('Offline - No network connection', {
              status: 503,
              headers: { 'Content-Type': 'text/plain' }
            });
          }
        }
      }
    ]
  })
);

self.addEventListener('activate', (event) => {
  event.waitUntil(
    Promise.all([
      clients.claim(),
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (!cacheName.startsWith('workbox-') &&
                cacheName !== 'fosdem-data' &&
                cacheName !== 'github-avatars' &&
                cacheName !== 'resized-images' &&
                cacheName !== 'navigations' &&
                cacheName !== 'user-data' &&
                cacheName !== 'default') {
              return caches.delete(cacheName);
            }
          })
        );
      })
    ])
  );
});

self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json();
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icons/android-chrome-192x192.png',
      badge: '/icons/android-chrome-72x72.png',
      data: data.url
    });
  }
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  if (event.notification.data) {
    event.waitUntil(
      clients.openWindow(event.notification.data)
    );
  }
});

self.addEventListener('sync', (event) => {
  if (event.tag === 'bookmark-sync') {
    event.waitUntil(syncBookmarks());
  }
});`

  writeFileSync(`${outputDir}/client/sw.js`, sw);
  console.info('Service worker generated successfully!');
}

const outputDir = process.argv[2] || 'dist';
generateServiceWorker(outputDir).catch(console.error)
